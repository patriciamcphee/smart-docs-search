"use strict";

function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
var path = require('path');
var fs = require('fs');
var lunr = require('lunr');
var minimatch = require('minimatch');

/**
 * Based on code from https://github.com/cmfcmf/docusaurus-search-local/
 * by Christian Flach, licensed under the MIT license.
 */
function generateLunrClientJS(outDir) {
  var language = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "en";
  if (Array.isArray(language) && language.length === 1) {
    language = language[0];
  }
  var lunrClient = "// THIS FILE IS AUTOGENERATED\n" + "// DO NOT EDIT THIS FILE!\n\n" + 'import * as lunr from "lunr";\n';
  if (language !== "en") {
    require("lunr-languages/lunr.stemmer.support")(lunr);
    lunrClient += 'require("lunr-languages/lunr.stemmer.support")(lunr);\n';
    if (Array.isArray(language)) {
      language.filter(function (code) {
        return code !== "en";
      }).forEach(function (code) {
        if (code === 'ja' || code === 'jp') {
          require("lunr-languages/tinyseg")(lunr);
          lunrClient += 'require("lunr-languages/tinyseg")(lunr);\n';
        }
        require("lunr-languages/lunr.".concat(code))(lunr);
        lunrClient += "require(\"lunr-languages/lunr.".concat(code, "\")(lunr);\n");
      });
      require("lunr-languages/lunr.multi")(lunr);
      lunrClient += "require(\"lunr-languages/lunr.multi\")(lunr);\n";
    } else {
      require("lunr-languages/lunr.".concat(language))(lunr);
      lunrClient += "require(\"lunr-languages/lunr.".concat(language, "\")(lunr);\n");
    }
  }
  lunrClient += "export default lunr;\n";
  var lunrClientPath = path.join(outDir, "lunr.client.js");
  fs.writeFileSync(lunrClientPath, lunrClient);
  if (language !== "en") {
    if (Array.isArray(language)) {
      return lunr.multiLanguage.apply(lunr, _toConsumableArray(language));
    } else {
      return lunr[language];
    }
  }
  return null;
}
function getFilePaths(routesPaths, outDir, baseUrl) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var files = [];
  var addedFiles = new Set();
  var _options$excludeRoute = options.excludeRoutes,
    excludeRoutes = _options$excludeRoute === void 0 ? [] : _options$excludeRoute,
    _options$includeRoute = options.includeRoutes,
    includeRoutes = _options$includeRoute === void 0 ? [] : _options$includeRoute,
    _options$indexBaseUrl = options.indexBaseUrl,
    indexBaseUrl = _options$indexBaseUrl === void 0 ? false : _options$indexBaseUrl;
  var meta = {
    excludedCount: 0
  };
  routesPaths.forEach(function (route) {
    if (route === "".concat(baseUrl, "404.html")) return;
    var isBaseUrl = route === baseUrl;
    if (isBaseUrl && !indexBaseUrl) {
      return;
    }
    var relativePath = route.replace(baseUrl, '');
    var candidatePaths = [route, relativePath].flatMap(function (route) {
      return [path.join(outDir, "".concat(route, ".html")), path.join(outDir, route, "index.html")];
    });
    var filePath = candidatePaths.find(fs.existsSync);
    if (filePath && !fs.existsSync(filePath)) {
      // if this error occurs, likely docusaurus changed some file generation aspects
      // and we need to update the candidates above
      console.warn("docusaurus-lunr-search: could not resolve file for route '".concat(route, "', it will be missing in the search index"));
    }

    // if we already added this file, skip it
    if (filePath && addedFiles.has(filePath)) return;

    // if we have include routes, skip if this route doesn't match any of them
    if (includeRoutes.length > 0 && !includeRoutes.some(function (includePattern) {
      return minimatch(route, includePattern) || minimatch(relativePath, includePattern);
    })) {
      meta.excludedCount++;
      return;
    }

    // if we have exclude routes, skip if this route matches any of them
    if (excludeRoutes.some(function (excludePattern) {
      return minimatch(route, excludePattern) || minimatch(relativePath, excludePattern);
    })) {
      meta.excludedCount++;
      return;
    }
    files.push({
      path: filePath,
      url: route
    });
    addedFiles.add(filePath);
  });
  return [files, meta];
}
module.exports = {
  generateLunrClientJS: generateLunrClientJS,
  getFilePaths: getFilePaths
};